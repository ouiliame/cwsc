contract TerraswapPair {
  state {
    pair_info: PairInfo
  }

  event ProvideLiquidity(
    sender: String,
    receiver: String,
    assets: [Asset; 2],
    share: String,
    refund_assets: [Asset; 2]
  );

  #instantiate(
    /// Asset infos
    asset_info: [AssetInfo; 2],
    /// Token contract code ID for initialization
    token_code_id: U64,
    asset_decimals: [U8; 2]
  ) {
    $state.pair_info = PairInfo {
      contract_addr: $env.contract.address,
      liquidity_token: Addr.empty(),
      asset_infos: [
        String!(msg.asset_infos[0]),
        String!(msg.asset_infos[1])
      ]
    };

    // TODO: reply annotation
    exec! Wasm.#instantiate(
      admin=None,
      code_id=token_code_id,
      msg=Cw20.#instantiate(
        name="terraswap liquidity token",
        symbol="uLP",
        decimals=6,
        initial_balances=[],
        mint=MinterResponse(
          minter=$env.contract.address,
          cap=None
        )
      ),
      funds=[],
      label="lp"
    );
  }

  fn query_pools!($, pair_info: PairInfo, addr: Address) {
    pair_info.asset_infos.map!(|ai| {
      return Asset(ai, query_pool!(ai, addr));
    })
  }

  fn query_pool!($, asset_info: AssetInfo, addr: Addr) -> U128 {
    if asset_info is AssetInfo.#Token {
      let res = query! Bank.#balance(asset_info.contract_addr, $state.balance[addr]);
      return res.balance;
    } else if asset_info is AssetInfo.#NativeToken {
      let res = query! Bank.#balance(addr, asset_info.denom);
      return res.amount.amount;
    } else {
      return 0;
    }
  }

  fn assert_sent_native_token_balance!($) {
    for asset in assets {
      if asset is AssetInfo.#NativeToken {
        let coin = $info.funds.find(|x| x.denom == denom);
        if coin? {
          if asset.amount != coin.amount {
            fail! "Native token balance mismatch between the argument and the transferred";
          }
        }
      } else if asset.amount != 0 {
        fail! "Native token balance mismatch between the argument and the transferred";
      }
    }
  }

  exec #receive([msg: Cw20ReceiveMsg]) {
    let contract_addr = $info.sender;
    let inner = deserialize![Cw20HookMsg](msg.msg);
    if inner is Cw20HookMsg.#Swap {
      let { belief_price, max_spread, to, deadline } = inner;
      let authorized = false;
      let config = $state.pair_info;
      let pools = $.query_pools($env.contract.address);
      for pool in pools {
        if pool.info is AssetInfo.#Token and pool.info.contract_addr == $info.sender {
          authorized = true;
        }
      }

      if !authorized {
        fail! Unauthorized();
      }

      let to_addr = if to? {
        Addr.validate!(to.to_addr)
      } else {
        None
      };

      let asset = Asset(
        info=AssetInfo.#Token { contract_addr },
        amount=msg.amount
      );

      $.swap(Addr.unchecked(msg.sender), asset, belief_price, max_spread, to_addr, deadline);
    } else if inner is Cw20HookMsg.#WithdrawLiquidity {
      let { min_assets, deadline } = inner;
      let config = $state.pair_info;
      if Addr.canonicalize!($info.sender) != config.liquidity_token {
        fail! Unauthorized();
      }
      let sender_addr = Addr.validate!(cw20_msg.sender);

      $.withdraw_liquidity(sender_addr, msg.amount, min_assets, deadline);
    }
  }

  exec #provide_liquidity(
    assets: [Asset; 2],
    receiver?: String,
    deadline?: U64,
    slippage_tolerance?: Dec
  ) {
    $.assert_deadline!($env.block.time.seconds(), deadline);

    for asset in assets {
      $.assert_sent_native_token_balance($info);
    }

    let { pair_info } = $state;
    let pools = $.query_pools($env.contract.address);
    
    let deposits = [
      assets.find(|a| a.info == pools[0].info).map(|a| a.amount) ?? fail! "wrong asset info is given",
      assets.find(|a| a.info == pools[1].info).map(|a| a.amount) ?? fail! "wrong asset info is given"
    ];

    for [i, pool] in pools.enumerate() {
      if pool.is_native_token() {
        pool.amount -= deposits[i];
      }
    }

    let { liquidity_token } = pair_info;
    let { total_share } = query! $.#token_info();

    let share: U128 = if total_share == 0 {
      let deposit0 = U128!(deposits[0]);
      let deposit1 = U128!(deposits[1]);
      let share = U256!(
        Dec256.ratio!(deposit 0 * deposit1, U256(1)).sqrt() * U256(1)
      )
      exec! Cw20(liquidity_token).#mint(recipient=$env.contract.address, amount=MINIMUM_LIQUIDITY_AMOUNT);
      share.sub!(MINIMUM_LIQUIDITY_AMOUNT) ?? fail! MinimumLiquidityAmountError(MINIMUM_LIQUIDITY_AMOUNT, share);
    } else {
      min[U128](
        deposits[0].multiply_ratio(total_share, pools[0].amount),
        deposits[1].multiply_ratio(total_share, pools[1].amount)
      )
    }

    // prevent providing free token
    if share == 0 {
      fail! InvalidZeroAmount();
    }

    // refund of remaining native token & desired of token
    let refund_assets = List[Asset]();
    for [i, pool] in pools.enumerate() {
      let desired_amount = if total_share == 0 {
        deposits[i]
      } else {
        let desired_amount = pool.amount.multiply_ratio(share, total_share);
        if desired_amount.multiply_ratio(total_share, share) != pool.amount {
          desired_amount += 1;
        }
        desired_amount
      }

      let remain_amount = deposits[i] - desired_amount;
      if slippage_tolerance? and remain_amount > deposits[i] * slippage_tolerance {
        fail! MaxSlippageAssertion();
      }

      refund_assets.push(Asset(info=pool.info, amount=remain_amount));
      if pool.info is AssetInfo.#NativeToken {
        if remain_amount != is_zero() {
          exec! Bank.#send(to_address=$info.sender, amount=[Coin(remain_amount, pool.info.denom)]);
        }
      } else if pool.info is AssetInfo.#Token {
        exec! Cw20(pool.info.contract_addr).#transfer_from(
          owner=$info.sender,
          recipient=$env.contract.address,
          amount=desired_amount
        ); 
      }
    }

    // mint LP token to sender
    let receiver = receiver ?? $info.sender;
    exec! Cw20(pair_info.liquidity_token).#mint(recipient=receiver, amount=share);
    emit ProvideLiquidity($info.sender, receiver, assets[0], assets[1], share);
  }

  fn compute_swap!(offer_pool: U128, ask_pool: U128, offer_amount: U128) -> [U128; 3] {
    let offer_pool = U256!(offer_pool);
    let ask_pool = U256!(ask_pool);
    let offer_amount = U256!(offer_amount);
    
    let commission_rate = Dec256!(COMMISSION_RATE);
    let cp = offer_pool.mul!(ask_pool);
    let return_amount = (
      Dec256.ratio!(ask_pool, 1) - Dec256.ratio!(cp, offer_pool + offer_amount) * U256(1)
    );
    let spread_amount = (
      offer_amount * Dec256.ratio!(ask_pool, offer_pool) - return_amount
    );
    let commission_amount = return_amount * commission_rate;
    return_amount -= commission_amount;
    return [U128!(return_amount), U128!(spread_amount), U128!(commission_amount)];
  }

  exec #swap(
    offer_asset: Asset,
    belief_price?: Dec,
    max_spread?: Dec,
    to?: Addr,
    deadline?: U64
  ) {
    assert_sent_native_token_balance!();
    let { pair_info } = $state;
    let pools = $.query_pools!(pair_info, $env.contract.address);

    if offer_asset.info == pools[0].info {
      let offer_pool = Asset(pools[0].info, pools[0].amount - offer_asset.amount);
      let ask_pool = pools[1];
      let offer_decimal = pair_info.asset_decimals[0];
      let ask_decimal = pair_info.asset_decimals[1];
    }

    if offer_asset is AssetInfo.#NativeToken {
      fail! Unauthorized()
    } else if offer_asset.info == pools[1].info {
      let offer_pool = Asset {
        amount: pools[1].amount - offer_asset.amount,
        info: pools[1].info
      };
      let ask_pool = pools[0];
      let offer_decimal = pair_info.asset_decimals[1];
      let ask_decimal = pair_info.asset_decimals[0];
    } else {
      fail! AssetMismatch();
    }

    let offer_amount = offer_asset.amount;
    let [return_amount, spread_amount, commission_amount] = compute_swap!(
      offer_pool.amount, ask_pool.amount, offer_amount
    );

    let return_asset = Asset(ask_pool.info, return_amount);
    $.assert_max_spread!(belief_price, max_spread, offer_asset, return_asset, spread_amount, offer_decimal, ask_decimal);
    
    let receiver = to ?? sender;
    if return_amount != 0 {
      if return_asset is AssetInfo.#Token {
        exec! Wasm.#execute(return_asset.contract_addr, CW20.#transfer(recipient, amount));
      } else {
        exec! Bank.#send(to_address, Coin(amount, denom));
      }
    }
    emit Swap(sender, receiver, offer_asset.info, ask_pool.info, offer_amount, spread_amount, commission_amount);
  }

  query #pair() {
    return $state.pair_info;
  }

  query #pool() {
    let { pair_info } = $state;
    let { contract_addr } = pair_info;
    let assets = $.query_pools!(pair_info, contract_addr);
    let { total_share } = query! CW20(contract_addr).#token_info();
    return PoolResponse {
      assets, total_share
    };
  }

  query #simulation(offer_asset: Asset) {
    let pair_info = $state.pair_info;
    let { contract_addr } = pair_info;

    let pools = $.query_pools!(pair_info, contract_addr);
    if offer_asset.info == pools[0] {
      let [offer_pool, ask_pool] = [pools[0], pools[1]];
    } else if offer_asset.info == pools[1] {
      let [offer_pool, ask_pool] = [pools[1], pools[0]];
    } else {
      fail! AssetMismatch();
    }

    let [return_amount, spread_amount, commission_amount] = $.compute_swap!(
      offer_pool.amount, ask_pool.amount, offer_asset.amount
    );

    return SimulationResponse {
      return_amount, spread_amount, commission_amount
    };
  }

  query #reverse_simulation(ask_asset: Asset) {
    let { contract_addr } = $state.pair_info;
    
    let pools = $.query_pools(pair_info, contract_addr);

    if ask_asset.info == pools[0] {
      let [ask_pool, offer_pool] = [pools[0], pools[1]];
    } else if ask_asset.info == pools[1] {
      let [ask_pool, offer_pool] = [pools[1], pools[0]];
    } else {
      fail! AssetMismatch();
    }
    
    let [offer_amount, spread_amount, commission_amount] = compute_offer_amount!(
      offer_pool.amount, ask_pool.amount, ask_asset.amount
    )

    return ReverseSimulationResponse {
      offer_amount, spread_amount, commission_amount
    };
    
  }
}