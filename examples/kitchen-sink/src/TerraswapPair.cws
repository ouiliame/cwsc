export struct Asset {
  info: AssetInfo,
  amount: U128
}

export enum AssetInfo {
  #Token(contract_addr: String),
  #NativeToken(denom: String)
}

export contract TerraswapPair {
  state {
    pair_info: struct PairInfo {
      asset_infos: [AssetInfo; 2],
      contract_addr: String,
      liquidity_token: String,
      asset_decimals: [U8; 2],
    }
  }

  event ProvideLiquidity(
    sender: String,
    receiver: String,
    assets: [Asset; 2],
    share: String,
    refund_assets: [Asset; 2]
  );

  event WithdrawLiquidity(
    sender: String,
    withdrawn_share: String,
    refund_assets: [Asset; 2]
  );

  #instantiate(
    /// Asset infos
    asset_info: [AssetInfo; 2],
    /// Token contract code ID for initialization
    token_code_id: U64,
    asset_decimals: [U8; 2]
  ) {
    $state.pair_info = PairInfo {
      contract_addr: $env.contract.address,
      liquidity_token: Addr.empty(),
      asset_infos: [
        String!(asset_info[0]),
        String!(asset_info[1])
      ],
      asset_decimals: asset_decimals
    };

    exec! Wasm.#instantiate(
      admin=None,
      code_id=token_code_id,
      msg=Cw20.#instantiate(
        name="terraswap liquidity token",
        symbol="uLP",
        decimals=6,
        initial_balances=[],
        mint=MinterResponse(
          minter=$env.contract.address,
          cap=None
        )
      ),
      funds=[],
      label="lp"
    ).reply_on_success(gas_limit=None, id=INSTANTIATE_REPLY_ID);
  }

  fn query_pools!($, pair_info: PairInfo, addr: Address) -> List[Asset] {
    pair_info.asset_infos.map!(|ai| {
      return Asset(ai, query_pool!(ai, addr));
    })
  }

  fn query_pool!($, asset_info: AssetInfo, addr: Addr) -> U128 {
    if asset_info is AssetInfo.#Token {
      let res = query! Bank.#balance(asset_info.contract_addr, $state.balance[addr]);
      return res.balance;
    } else if asset_info is AssetInfo.#NativeToken {
      let res = query! Bank.#balance(addr, asset_info.denom);
      return res.amount.amount;
    } else {
      return 0;
    }
  }

  fn compute_offer_amount!(offer_pool: U128, ask_pool: U128, ask_amount: U128) -> [U128, U128, U128] {
    let commission_rate = Dec.permille(COMMISSION_RATE);

    let cp = offer_pool * ask_pool;
    let one_minus_commission = Dec.one() - commission_rate;
    let inv_one_minus_commission = Dec.one() / one_minus_commission;
    let before_commission_deduction = ask_amount * inv_one_minus_commission;
    if before_commission_deduction * one_minus_commission != ask_amount {
      before_commission_deduction += U256(1);
    }

    let after_ask_pool = ask_pool - before_commission_deduction;
    let after_offer_pool = U256(1).multiply_ratio(cp, after_ask_pool);

    if after_offer_pool * (ask_pool - before_commission_deduction) != cp {
      after_offer_pool += U256(1);
    }

    let offer_amount = after_offer_pool - offer_pool;
    let before_spread_deduction = offer_amount * Dec.ratio(ask_pool, offer_pool);

    let spread_amount = if before_spread_deduction > before_commission_deduction {
      before_commission_deduction - before_commission_deduction
    } else {
      U256(0)
    };

    let commission_amount = before_commission_deduction - ask_amount;
    return [U256!(offer_amount), U256!(spread_amount), U256!(commission_amount)];
  }

  fn assert_max_spread!(
    belief_price: Dec?,
    max_spread: Dec?,
    offer_asset: Asset,
    return_asset: Asset,
    spread_amount: U128,
    offer_decimal: U8,
    return_decimal: U8
  ) {
    let [offer_amount, return_amount, spread_amount] = if offer_decimal > return_decimal {
      let diff_decimal = U64(10).pow(offer_decimal - return_decimal);
      [offer_asset.amount, return_asset.amount * U128!(diff_decimal), spread_amount * U128!(diff_decimal)]
    } else if offer_decimal < return_decimal {
      let diff_decimal = U64(10).pow(return_decimal - offer_decimal);
      [offer_asset.amount * U128!(diff_decimal), return_asset.amount, spread_amount]
    } else if offer_decimal == return_decimal {
      [offer_asset.amount, return_asset.amount, spread_amount]
    };

    if max_spread? and belief_price? {
      let expected_return = offer_amount * (Dec.one() / belief_price);
      let spread_amount = if expected_return > return_amount {
        expected_return - return_amount
      } else {
        U256.zero()
      };
      if return_amount < expected_return and Dec.ratio(spread_amount, expected_return) > max_spread {
        fail! MaxSpreadAssertion();
      }
    } else if max_spread? {
      if Dec.ratio(spread_amount, return_amount + spread_amount) > max_spread {
        fail! MaxSpreadAssertion();
      }
    }
  }

  fn assert_deadline!(blocktime: U64, deadline?: U64) {
    if deadline? {
      fail! ExpiredDeadline();
    }
  }

  fn assert_minimum_assets!(assets: List[Asset], min_assets?: [Asset; 2]) {
    if min_assets? {
      for min_asset in min_assets {
        let asset = assets.find(|asset| asset.info == min_asset.info);
        if asset? {
          if asset.amount < min_asset.amount {
            fail! MinAmountAssertion(min_asset=min_asset, asset=asset);
          }
        } else {
          fail! MinAmountAssetion(min_asset=min_asset, asset=Asset(info=min_asset.info, amount=0));
        }
      }
    }
  }

  fn assert_sent_native_token_balance!(asset: Asset, funds: List[Coin]) {
    if asset.info is AssetInfo.#NativeToken {
      let coin = funds.find(|x| x.denom == asset.info.denom);
      if coin? {
        if asset.amount != coin.amount {
          fail! "Native token balance mismatch between the argument and the transferred";
        }
      }
    } else if asset.amount != 0 {
      fail! "Native token balance mismatch between the argument and the transferred";
    }
  }

  exec #receive([msg: Cw20ReceiveMsg]) {
    let contract_addr = $info.sender;
    let inner = deserialize![Cw20HookMsg](msg.msg);
    if inner is Cw20HookMsg.#Swap {
      let { belief_price, max_spread, to, deadline } = inner;
      let authorized = false;
      let config = $state.pair_info;
      let pools = $.query_pools(config, $env.contract.address);
      for pool in pools {
        if pool.info is AssetInfo.#Token and pool.info.contract_addr == $info.sender {
          authorized = true;
        }
      }

      if not authorized {
        fail! Unauthorized();
      }

      let to_addr = if to? {
        Addr.validate!(to.to_addr)
      } else {
        None
      };

      let asset = Asset(
        info=AssetInfo.#Token { contract_addr },
        amount=msg.amount
      );

      $.swap(Addr.unchecked(msg.sender), asset, belief_price, max_spread, to_addr, deadline);
    } else if inner is Cw20HookMsg.#WithdrawLiquidity {
      let { min_assets, deadline } = inner;
      let config = $state.pair_info;
      if Addr.canonicalize!($info.sender) != config.liquidity_token {
        fail! Unauthorized();
      }
      let sender_addr = Addr.validate!(msg.sender);

      $.withdraw_liquidity(sender_addr, msg.amount, min_assets, deadline);
    }
  }

  exec #provide_liquidity(
    assets: [Asset; 2],
    receiver?: String,
    deadline?: U64,
    slippage_tolerance?: Dec
  ) {
    $.assert_deadline!($env.block.time.seconds(), deadline);

    for asset in assets {
      assert_sent_native_token_balance!(asset, $info.funds);
    }

    let { pair_info } = $state;
    let pools = $.query_pools(pair_info, $env.contract.address);
    
    let deposits = [
      assets.find(|a| a.info == pools[0].info).map(|a| a.amount) ?? fail! "wrong asset info is given",
      assets.find(|a| a.info == pools[1].info).map(|a| a.amount) ?? fail! "wrong asset info is given"
    ];

    for [i, pool] in pools.enumerate() {
      if pool.is_native_token() {
        pool.amount -= deposits[i];
      }
    }

    let { liquidity_token } = pair_info;
    let { total_share } = query! $.#token_info();

    let share: U128 = if total_share == 0 {
      let deposit0 = U128!(deposits[0]);
      let deposit1 = U128!(deposits[1]);
      let share = U256!(
        Dec.ratio(deposits[0] * deposit1, U256(1)).sqrt() * U256(1)
      )
      exec! Cw20(liquidity_token).#mint(recipient=$env.contract.address, amount=MINIMUM_LIQUIDITY_AMOUNT);
      share.sub!(MINIMUM_LIQUIDITY_AMOUNT) ?? fail! MinimumLiquidityAmountError();
    } else {
      min[U128](
        deposits[0].multiply_ratio(total_share, pools[0].amount),
        deposits[1].multiply_ratio(total_share, pools[1].amount)
      )
    }

    // prevent providing free token
    if share == 0 {
      fail! InvalidZeroAmount();
    }

    // refund of remaining native token & desired of token
    let refund_assets = List[Asset]();
    for [i, pool] in pools.enumerate() {
      let desired_amount = if total_share == 0 {
        deposits[i]
      } else {
        let desired_amount = pool.amount.multiply_ratio(share, total_share);
        if desired_amount.multiply_ratio(total_share, share) != pool.amount {
          desired_amount += 1;
        }
        desired_amount
      }

      let remain_amount = deposits[i] - desired_amount;
      if slippage_tolerance? and remain_amount > deposits[i] * slippage_tolerance {
        fail! MaxSlippageAssertion();
      }

      refund_assets.push(Asset(info=pool.info, amount=remain_amount));
      if pool.info is AssetInfo.#NativeToken {
        if not remain_amount.is_zero() {
          exec! Bank.#send(to_address=$info.sender, amount=[Coin(remain_amount, pool.info.denom)]);
        }
      } else if pool.info is AssetInfo.#Token {
        exec! Cw20(pool.info.contract_addr).#transfer_from(
          owner=$info.sender,
          recipient=$env.contract.address,
          amount=desired_amount
        );
      }
    }

    // mint LP token to sender
    let receiver = receiver ?? $info.sender;
    exec! Cw20(pair_info.liquidity_token).#mint(recipient=receiver, amount=share);
    emit! ProvideLiquidity($info.sender, receiver, assets[0], assets[1], share);
  }

  fn compute_swap!(offer_pool: U128, ask_pool: U128, offer_amount: U128) -> [U128; 3] {
    let offer_pool = U256!(offer_pool);
    let ask_pool = U256!(ask_pool);
    let offer_amount = U256!(offer_amount);
    
    let commission_rate = Dec.permille(COMMISSION_RATE);
    let return_amount = (ask_pool * offer_amount) / (offer_pool + offer_amount);
    let spread_amount = (
      (offer_amount * Dec.ratio!(ask_pool, offer_pool)) - return_amount
    );
    let commission_amount = return_amount * commission_rate;
    if return_amount != (commission_amount * (Dec.one() / commission_rate)) {
      commission_amount += U256(128);
    }
    // commission will be returned to the pool
    return_amount -= commission_amount;
    return [U128!(return_amount), U128!(spread_amount), U128!(commission_amount)];
  }

  exec #swap(
    offer_asset: Asset,
    belief_price?: Dec,
    max_spread?: Dec,
    to?: Addr,
    deadline?: U64
  ) {
    assert_sent_native_token_balance!(offer_asset, $info.funds);
    let { pair_info } = $state;
    let pools = $.query_pools!(pair_info, $env.contract.address);

    if offer_asset.info == pools[0].info {
      let offer_pool = Asset(pools[0].info, pools[0].amount - offer_asset.amount);
      let ask_pool = pools[1];
      let offer_decimal = pair_info.asset_decimals[0];
      let ask_decimal = pair_info.asset_decimals[1];
    }

    if offer_asset is AssetInfo.#NativeToken {
      fail! Unauthorized()
    } else if offer_asset.info == pools[1].info {
      let offer_pool = Asset {
        amount: pools[1].amount - offer_asset.amount,
        info: pools[1].info
      };
      let ask_pool = pools[0];
      let offer_decimal = pair_info.asset_decimals[1];
      let ask_decimal = pair_info.asset_decimals[0];
    } else {
      fail! AssetMismatch();
    }

    let offer_amount = offer_asset.amount;
    let [return_amount, spread_amount, commission_amount] = compute_swap!(
      offer_pool.amount, ask_pool.amount, offer_amount
    );

    let return_asset = Asset(ask_pool.info, return_amount);
    $.assert_max_spread!(belief_price, max_spread, offer_asset, return_asset, spread_amount, offer_decimal, ask_decimal);
    
    let receiver = to ?? $info.sender;
    if return_amount != 0 {
      if return_asset is AssetInfo.#Token {
        exec! Wasm.#execute(return_asset.contract_addr, CW20.#transfer(recipient, amount));
      } else {
        exec! Bank.#send(to_address, Coin(amount, denom));
      }
    }
    emit! Swap(sender, receiver, offer_asset.info, ask_pool.info, offer_amount, spread_amount, commission_amount);
  }

  exec #withdraw_liquidity(
    sender: Addr,
    amount: U128,
    min_assets: [Asset; 2]?,
    deadline?: U64
  ) {
    $.assert_deadline!($env.block.time.seconds(), deadline)?;
    
    let { pair_info } = $state;
    let liquidity_addr = Addr.humanize!(pair_info.liquidity_token);
    
    let pools = $.query_pools!(pair_info, $env.contract.address);
    let { total_share } = $.query_token_info!(liquidity_addr);

    let share_ratio = Dec.ratio(amount, total_share);
    let refund_assets = pools.map(|a| Asset(info=a.info, amount=a.amount * share_ratio));
    
    $.assert_minimum_assets!(refund_assets, min_assets);
    // TODO: exec refund_assets[0].clone().into_msg(sender.clone())?
    exec! Cw20(pair_info.liquidity_token).#burn(amount);
    emit! WithdrawLiquidity(sender=sender, withdrawn_share=amount, refund_assets);
  }

  query #pair() {
    return $state.pair_info;
  }

  query #pool() {
    let { pair_info } = $state;
    let { contract_addr } = pair_info;
    let assets = $.query_pools!(pair_info, contract_addr);
    let { total_share } = query! CW20(contract_addr).#token_info();
    return PoolResponse {
      assets, total_share
    };
  }

  query #simulation(offer_asset: Asset) {
    let pair_info = $state.pair_info;
    let { contract_addr } = pair_info;

    let pools = $.query_pools!(pair_info, contract_addr);
    if offer_asset.info == pools[0].info {
      let [offer_pool, ask_pool] = [pools[0], pools[1]];
    } else if offer_asset.info == pools[1].info {
      let [offer_pool, ask_pool] = [pools[1], pools[0]];
    } else {
      fail! AssetMismatch();
    }

    let [return_amount, spread_amount, commission_amount] = $.compute_swap!(
      offer_pool.amount, ask_pool.amount, offer_asset.amount
    );

    return SimulationResponse {
      return_amount, spread_amount, commission_amount
    };
  }

  query #reverse_simulation(ask_asset: Asset) {
    let pair_info = $state.pair_info;
    let { contract_addr } = pair_info;

    let pools = $.query_pools(pair_info, contract_addr);

    if ask_asset.info == pools[0].info {
      let [ask_pool, offer_pool] = [pools[0], pools[1]];
    } else if ask_asset.info == pools[1].info {
      let [ask_pool, offer_pool] = [pools[1], pools[0]];
    } else {
      fail! AssetMismatch();
    }
    
    let [offer_amount, spread_amount, commission_amount] = compute_offer_amount!(
      offer_pool.amount, ask_pool.amount, ask_asset.amount
    )

    return ReverseSimulationResponse {
      offer_amount, spread_amount, commission_amount
    };
    
  }
}