contract KitchenSink {
  state {
    a: Int;
    b: String;
    c: struct InlineA {}
  }

  error ErrA();
  error ErrB(a: Int, b: String);

  event EventA();
  event EventB(a: Int, b: String);

  #instantiate(a: Int, b: String) {}
  exec #exec_a() {}
  exec #exec_b(a: Int, b: String) {}

  query #query_a() {}
  query #query_b(a: Int, b: String) {}
  query #bob(a: String, b: String, c: String) {
  }

  struct StructA {}
  struct StructB {
    a: Int,
    b: String
  }
  struct StructC()
  struct StructD(a: Int, b: String)
  struct StructE[%T, %U] {
    a: %T,
    b: %U
  }

  tuple TupA([]);
  tuple TupB([Int, String]);
  tuple TupC[%T]([%T, Int, %T]);

  unit UnitA;
  unit UnitB;

  type TypeAliasA = None;
  type TypeAliasB[%T] = struct InlineB {
    a: %T
  };

  enum EnumA {
    #StructVariantA {},
    #StructVariantB { a: Int, b: String },
    #StructVariantC(),
    #StructVariantD(a: Int, b: String),
    #TupleVariantA([]),
    #TupleVariantB([Int, String]),
    #UnitVariantA,
    #UnitVariantB
  }

  fn fn_a() {}
  fn fn_b(a: Int, b: String) {}
  fn fn_c!() {}
  fn fn_d!(a: Int, b: String) {}
  fn fn_e[%T]() {}
  fn fn_f[%T](x: %T) {}
  fn fn_g![%T]() {}
  fn fn_h![%T](x: %T) {}
}