# Ralph Progress Log
Started: Thu Feb 12 14:42:07 PST 2026

## Codebase Patterns
- The e2e script takes project and contract as CLI args: `bun run src/e2e.ts <project> <Contract>` (e.g., `kitchen-sink TerraswapPair`)
- The stash from feat/cwsfmt contains the improved codegen pipeline - must be applied before working on cargo check errors
- `formatRust()` must be async because prettier.format returns a Promise; `writeToDisk()` must also be async
- `ctx._args` in ANTLR parse tree can contain null entries - always filter before mapping
- Counter.cws output has 2 pre-existing errors in schema.rs (wrong import path `counter::msg` vs `counter::counter::msg`) - not in lib.rs
- CWScript `$info.sender` compiles to Rust `ctx.info.sender.clone()`
- CWScript `$state.pair_info` compiles to Rust `PAIR_INFO.load(ctx.deps.storage)?`
- Generated Rust is at `examples/<project>/build/<crate-name>/src/lib.rs`
- `visitIfExpr` in block-to-cg.ts handles `else if` branches; `visitIfStmt` handles top-level if statements — both need auto-unwrap logic for `.is_some()` checks
- CWScript `else if x?` is parsed as an IfExpr (expression) inside the else block, NOT as an IfStmt — the grammar rule `blockOrExpr: block | expr` routes it through expr path
- CWScript `$` param in helper functions does NOT inject `ctx` as a Rust param — the block visitor translates `$info` → `ctx.info` but `ctx` is not available. For helper functions needing context, use explicit params instead of `$`
- `$.method()` strips the `$` and generates a direct function call; `$info.x` generates `ctx.info.x.clone()` — but `ctx` must exist in scope for this to work
- CWScript variables defined inside `if` blocks are not hoisted to outer scope in generated Rust — restructure as `let [a, b] = if cond { [x, y] } else { [x2, y2] }` to keep vars in outer scope
- When an `if/else if/else` chain has `fail!` in the else branch, the generated Rust `return Err(...)` has type `!` (never) which is compatible with any type, so it works as an if-expression value
- AST `Block.stmts` is a `List<Stmt>` (custom wrapper), NOT a plain array — use `.toArray()` or `.at(i)` to access elements, not `[i]`
- To detect enum destructuring patterns, check `extractEnumDestructure()` in both `visitIfStmt` AND `visitIfExpr` since `else if` branches go through IfExpr
- CWScript `U256!(x)` → Rust `Uint256::from(x)`, `U128!(x)` → Rust `Uint128::try_from(x).unwrap()` — use U256! for shadowing and U128! for conversion back
- CosmWasm: Uint256 can multiply with Decimal256 but NOT with Decimal; functions that shadow params to Uint256 need all Decimal operations upgraded to Decimal256
---

## 2026-02-12 - US-001
- What was implemented: Fixed 6 undefined variable references in TerraswapPair.cws source
- Files changed:
  - `examples/kitchen-sink/src/TerraswapPair.cws` - 6 variable name fixes
  - `src/parser/ast-builder.ts` - null safety in visitCallExpr and visitArg
  - `src/rust/format.ts` - made formatRust async with error handling
  - `src/rust/crate.ts` - made writeToDisk async
- **Learnings for future iterations:**
  - The codegen pipeline was in a git stash on feat/cwsfmt branch - needed to pop stash to get the 489-line generated Rust (vs 141-line skeleton)
  - The ralph branch needed to be created from feat/cwsfmt, not main, since all the compiler source (e2e, ast-builder, codegen) lives on that branch
  - Baseline error count is 70 (not 69 as PRD states) - close enough
  - CWScript `msg.xxx` in #instantiate refers to the message struct, but params are already destructured - use param names directly
  - `cw20_msg` is not a valid identifier in the CWScript source; it should be `msg` (the #receive handler param)
---

## 2026-02-12 - US-002
- What was implemented: Added missing `asset_decimals` field to PairInfo struct initializer in #instantiate
- Files changed:
  - `examples/kitchen-sink/src/TerraswapPair.cws` - added `asset_decimals: asset_decimals` to PairInfo initializer (line 49)
- **Learnings for future iterations:**
  - CWScript struct initializers map directly to Rust struct initializers — missing fields in CWScript = E0063 in Rust
  - The `asset_decimals` param was already passed to #instantiate but wasn't used in the PairInfo constructor
  - Error count: 64 → 63 (1 E0063 eliminated)
---

## 2026-02-12 - US-003
- What was implemented: Fixed assert_max_spread parameter type and Option unwrap in else-if branch
- Files changed:
  - `examples/kitchen-sink/src/TerraswapPair.cws` - changed `return_asset: U128` to `return_asset: Asset` on line 123
  - `src/e2e-helpers/block-to-cg.ts` - added auto-unwrap logic to `visitIfExpr` for `.is_some()` checks (matching existing `visitIfStmt` behavior)
- **Learnings for future iterations:**
  - CWScript `else if x?` routes through `visitIfExpr`, not `visitIfStmt` — any feature added to IfStmt auto-unwrap must also be added to IfExpr
  - The `mapType()` function correctly maps `Asset` as a pass-through type (not in PRIMITIVE_TYPE_MAP, so it gets returned as-is via IdentTypeExpr)
  - Fixing type errors can reveal latent errors — changing return_asset type exposed an E0317 (missing else clause) that was previously masked
  - Error count: 63 → 59 (5 errors fixed, 1 latent E0317 revealed, net -4)
---

## 2026-02-12 - US-004
- What was implemented: Fixed MinimumLiquidityAmountError positional args and deadline type in #withdraw_liquidity
- Files changed:
  - `examples/kitchen-sink/src/TerraswapPair.cws` - removed positional args from `fail! MinimumLiquidityAmountError()` (line 269), changed `deadline: U64` to `deadline?: U64` in #withdraw_liquidity params (line 394)
- **Learnings for future iterations:**
  - CWScript `fail! ErrorName(arg1, arg2)` generates Rust `ContractError::ErrorName { arg1, arg2 }` — if the error variant has no fields, the args must be removed from the CWScript source
  - CWScript `param?: Type` generates Rust `Option<Type>` — this is how optional params work, and it must match what calling functions expect
  - The codegen correctly propagates `?` to both the function signature AND the message enum variant
  - Error count: 59 → 56 (2 E0559 + 1 E0308 eliminated)
---

## 2026-02-12 - US-005
- What was implemented: Fixed 3 query_pools call sites that were missing the pair_info first argument
- Files changed:
  - `examples/kitchen-sink/src/TerraswapPair.cws` - added pair_info/config as first arg to query_pools calls in #receive (line 198), #provide_liquidity (line 246), #withdraw_liquidity (line 401)
- **Learnings for future iterations:**
  - CWScript function definitions with `$` context param: `fn query_pools!($, pair_info: PairInfo, addr: Address)` — the `$` is implicit context, actual args start after it
  - When fixing call sites, check what variable name holds pair_info in each scope — in #receive it's `config`, in #provide_liquidity and #withdraw_liquidity it's `pair_info`
  - Some call sites already had correct args (#swap, #pool, #simulation, #reverse_simulation) — only 3 of 7 were missing
  - Error count: 56 → 54 (2 E0061 eliminated; PRD predicted 3 but one was already fixed by line-number shifts from prior stories)
---

## 2026-02-12 - US-006
- What was implemented: Fixed assert_sent_native_token_balance function signature and call sites
- Files changed:
  - `examples/kitchen-sink/src/TerraswapPair.cws` - Removed `$` from fn signature, added explicit `asset: Asset` and `funds: List[Coin]` params; fixed `denom` → `asset.info.denom`; updated call sites in #provide_liquidity (loop over assets calling per-asset) and #swap (pass offer_asset directly)
- **Learnings for future iterations:**
  - CWScript `$` helper functions do NOT get `ctx` injected as a Rust param — the block visitor translates `$info` → `ctx.info` but `ctx` doesn't exist in the generated function. Workaround: use explicit params instead of `$`
  - When a function referenced caller-scope variables (`assets`, `denom`), the fix is to pass them as explicit parameters
  - Fixing scope issues can reveal latent type errors: `asset.info.denom` triggers E0609 (enum field access), `asset.amount != 0` triggers E0277 (Uint128 vs integer)
  - For functions that need to accept variable-length asset collections, making the function take a single Asset and looping at the call site avoids Vec vs array type mismatches
  - Error count: 54 → 52 (4 errors fixed, 2 latent errors revealed, net -2)
---

## 2026-02-12 - US-007
- What was implemented: Restructured CWScript source to eliminate if-block variable scoping issues
- Files changed:
  - `examples/kitchen-sink/src/TerraswapPair.cws` - Restructured 3 functions:
    - `exec #swap`: Replaced two separate if-blocks (one assigning vars for pools[0] match, another for pools[1] match with NativeToken check) with a single `let [offer_pool, ask_pool] = if ... else if ... else { fail! }` + separate `let [offer_decimal, ask_decimal] = if ... else { ... }`
    - `query #simulation`: Changed `if { let [a,b] = ... } else if { let [a,b] = ... }` to `let [a,b] = if ... else if ... else { fail! }`
    - `query #reverse_simulation`: Same pattern as simulation
- **Learnings for future iterations:**
  - CWScript does NOT hoist `let` bindings from inner blocks to outer scope in the generated Rust — this is a fundamental scoping mismatch
  - The fix is in the CWScript SOURCE, not the codegen: restructure to use `let [a, b] = if cond { [x, y] } else { [x2, y2] }` pattern
  - For mixed-type tuples (e.g., Asset + u8), split into separate `let` bindings since `[...]` generates a Rust array which requires homogeneous types
  - Removing the `if offer_asset is AssetInfo.#NativeToken { fail! Unauthorized() }` block from #swap was correct — it was a semantic error in the original CWScript (checking the wrong condition at the wrong place)
  - Error count: 52 → 43 (all 14 E0425 undefined variable errors eliminated, but some latent type errors became visible, net -9)
---

## 2026-02-12 - US-008
- What was implemented: Fixed Cw20HookMsg enum destructuring — `let { field } = inner` inside `if inner is Enum.#Variant` blocks now generates `if let Enum::Variant { field, .. } = inner` instead of `inner.field.clone()`
- Files changed:
  - `src/e2e-helpers/block-to-cg.ts` — Added `extractEnumDestructure()` helper method to CgBlockVisitor. This detects the pattern where an `IsExpr` predicate tests a variable against an enum variant, and the first statement in the if-body is a `LetStructStmt` destructuring that same variable. When detected, generates `if let Enum::Variant { fields, .. } = var { ... }` instead of `if matches!(var, Enum::Variant { .. }) { let field = var.field.clone(); ... }`. Applied to both `visitIfStmt` and `visitIfExpr`.
- **Learnings for future iterations:**
  - AST `Block.stmts` is a `List<Stmt>` (custom class), NOT a plain JS array — `stmts[0]` returns `undefined`! Must use `stmts.toArray()[0]` or `stmts.at(0)` to access elements
  - The `List<T>` class wraps `$children: T[]` internally and provides `.map()`, `.filter()`, `.toArray()`, `.at()`, `.length` etc. but does NOT support bracket indexing
  - When enum destructuring reveals new variables, those variables' types come from the enum variant definition — fixing destructuring can reveal latent type errors (e.g., `to.to_addr` where `to` is `Option<String>`, not an object with a `.to_addr` field)
  - Error count: 43 → 38 (6 E0609 enum field access errors eliminated, 1 latent E0609 `to.to_addr` revealed, net -5)
---

## 2026-02-12 - US-009
- What was implemented: Fixed compute_offer_amount Uint128/Uint256 type mixing by adding Uint256 param shadowing (matching compute_swap pattern)
- Files changed:
  - `examples/kitchen-sink/src/TerraswapPair.cws` — Added `let offer_pool = U256!(offer_pool); let ask_pool = U256!(ask_pool); let ask_amount = U256!(ask_amount);` at start of compute_offer_amount. Changed return from `U256!()` to `U128!()` for correct back-conversion.
- **Learnings for future iterations:**
  - The `compute_swap` function is the reference pattern: shadow Uint128 params with Uint256::from() at start, do Uint256 arithmetic internally, convert back with Uint128::try_from().unwrap() at return
  - Shadowing params with Uint256 fixes most type-mixing errors but introduces Uint256*Decimal errors — CosmWasm doesn't implement Mul<Decimal> for Uint256, only Mul<Decimal256>. This is a cross-cutting issue affecting both compute_swap and compute_offer_amount
  - CWScript `U256!(x)` generates `Uint256::from(x)` and `U128!(x)` generates `Uint128::try_from(x).unwrap()` — the `!` suffix triggers macro-style codegen
  - PRD error count estimates can be inaccurate when errors overlap across multiple stories (e.g., Uint256*Decimal is in both US-009 and US-014)
  - Error count: 38 → 37 (multiple Uint128/Uint256 mixing errors eliminated, 1 new Uint256*Decimal error introduced by shadowing, net -1)
---
